use nietzsche_graph::{AdjacencyIndex, GraphStorage};

use crate::config::AgencyConfig;
use crate::circuit_breaker::EnergyCircuitBreaker;
use crate::daemons::{AgencyDaemon, CoherenceDaemon, DaemonReport, EntropyDaemon, EvolutionDaemon, GapDaemon, LTDDaemon, NiilistaGcDaemon, NeuralThresholdDaemon};
use crate::desire::{DesireEngine, DesireSignal};
use crate::error::AgencyError;
use crate::event_bus::{AgencyEvent, AgencyEventBus, SectorId};
use crate::identity::ObserverIdentity;
use crate::observer::{HealthReport, MetaObserver};
use crate::reactor::{AgencyIntent, AgencyReactor};

use std::collections::{hash_map::DefaultHasher, HashSet};
use std::hash::{Hash, Hasher};
use uuid::Uuid;

/// Full tick report from the agency engine.
#[derive(Debug)]
pub struct AgencyTickReport {
    pub daemon_reports: Vec<DaemonReport>,
    pub health_report: Option<HealthReport>,
    /// Intents produced by the reactor — the server should execute these
    /// under a write lock after the tick completes.
    pub intents: Vec<AgencyIntent>,
    /// Desire signals generated by the Motor de Desejo.
    pub desires: Vec<DesireSignal>,
    pub duration_ms: u64,
}

/// Top-level agency engine that orchestrates daemons, observer, reactor,
/// desire engine, and event bus.
///
/// Create once and call [`tick`](AgencyEngine::tick) periodically from a
/// background Tokio task. The engine holds only configuration and lightweight
/// state (observer tick counter + event buffer + reactor cooldowns).
///
/// ## Tick protocol
///
/// 1. Tick each daemon sequentially (read-only graph scan + analysis + emit events)
/// 2. Tick the observer (drain events + aggregate metrics + maybe produce HealthReport)
/// 3. Tick the reactor (drain events + produce intents)
/// 4. Process knowledge gaps through the Motor de Desejo
/// 5. Update Observer Identity meta-node with latest health
/// 6. Return combined `AgencyTickReport` with intents + desires
pub struct AgencyEngine {
    pub config: AgencyConfig,
    bus: AgencyEventBus,
    daemons: Vec<Box<dyn AgencyDaemon>>,
    observer: MetaObserver,
    reactor: AgencyReactor,
    desire_engine: DesireEngine,
    /// Collects gap events from daemons for the desire engine.
    gap_rx: tokio::sync::broadcast::Receiver<AgencyEvent>,
    circuit_breaker: EnergyCircuitBreaker,
    /// HashSet of actions currently on cooldown (O(1) access).
    pub active_reflex_cooldowns: HashSet<Uuid>,
}

impl AgencyEngine {
    pub fn new(config: AgencyConfig) -> Self {
        let bus = AgencyEventBus::new(256);
        let observer = MetaObserver::new(&bus);
        let ppo_engine = nietzsche_rl::PpoEngine::new(nietzsche_rl::PpoConfig {
            model_name: config.ppo_model_name.clone(),
            ..Default::default()
        });
        let reactor = AgencyReactor::new(&bus, Some(ppo_engine));
        let desire_engine = DesireEngine::new();
        let gap_rx = bus.subscribe();
        Self {
            daemons: vec![
                Box::new(EntropyDaemon),
                Box::new(GapDaemon),
                Box::new(CoherenceDaemon),
                Box::new(NiilistaGcDaemon),
                Box::new(LTDDaemon),
                Box::new(EvolutionDaemon),
                Box::new(NeuralThresholdDaemon::new(&config.gnn_model_name)),
            ],
            observer,
            reactor,
            desire_engine,
            gap_rx,
            bus,
            circuit_breaker: EnergyCircuitBreaker {
                max_active_reflexes: config.circuit_breaker_max_actions,
                energy_sum_threshold: config.circuit_breaker_energy_sum_threshold,
            },
            active_reflex_cooldowns: HashSet::new(),
            config,
        }
    }

    /// Create from environment variables.
    pub fn from_env() -> Self {
        Self::new(AgencyConfig::from_env())
    }

    /// Run one tick of the full agency cycle.
    ///
    /// Takes only shared references to storage and adjacency — the agency
    /// engine is completely **read-only** and never mutates the graph
    /// (except for CF_META writes which are atomic at RocksDB level).
    /// Any structural mutations are expressed as `AgencyIntent`s for the
    /// server to execute under a write lock.
    pub fn tick(
        &mut self,
        storage: &GraphStorage,
        adjacency: &AdjacencyIndex,
    ) -> Result<AgencyTickReport, AgencyError> {
        let t0 = std::time::Instant::now();

        // 1. Tick each daemon
        let mut daemon_reports = Vec::with_capacity(self.daemons.len());
        for daemon in &self.daemons {
            let report = daemon.tick(storage, adjacency, &self.bus, &self.config)?;
            tracing::debug!(
                daemon = daemon.name(),
                events = report.events_emitted,
                scanned = report.nodes_scanned,
                us = report.duration_us,
                "daemon tick"
            );
            daemon_reports.push(report);
        }

        // 2. Tick observer (may emit HealthReport + WakeUp events)
        let health_report = self.observer.tick(storage, adjacency, &self.bus, &self.config)?;

        // 3. Tick reactor (converts events → intents)
        let mut intents = self.reactor.tick(&self.config);

        if !intents.is_empty() {
            tracing::info!(
                intent_count = intents.len(),
                "agency reactor produced intents"
            );
        }

        // 4. Collect gap events and feed to desire engine
        let gaps = self.drain_gap_events();
        let desires = self.desire_engine.process_gaps(&gaps, storage, &self.bus, &self.config)?;

        // 5. Desire → Dream: trigger dreams for high-priority desires
        let dream_intents = self.generate_dream_intents(&desires, storage);
        intents.extend(dream_intents);

        // 6. Update Observer Identity with latest health (if report was generated)
        if let Some(ref health) = health_report {
            if let Err(e) = ObserverIdentity::update_from_health(storage, health) {
                tracing::warn!(error = %e, "failed to update observer identity");
            }
        }

        // 7. Tick Code-as-Data (Reflexive Actions)
        if let Ok(report) = crate::code_as_data::scan_activatable_actions(storage) {
            if !report.activated.is_empty() {
                // Check safety via circuit breaker
                match self.circuit_breaker.check_safety(storage, report.activated.len()) {
                    Ok(true) => {
                        for action in report.activated {
                            intents.push(AgencyIntent::ExecuteNQL {
                                node_id: action.node_id,
                                nql: action.nql,
                                description: action.description,
                            });
                            // Add to memory-active cooldown set
                            self.active_reflex_cooldowns.insert(action.node_id);
                        }
                    }
                    Ok(false) => {
                        tracing::warn!("agency tick: reflexive actions blocked by circuit breaker");
                    }
                    Err(e) => tracing::error!(error = ?e, "circuit breaker check failed"),
                }
            }
            // Tick cooldowns using optimized HashSet (avoids O(N) scan)
            if !self.active_reflex_cooldowns.is_empty() {
                match crate::code_as_data::tick_cooldowns_optimized(storage, &self.active_reflex_cooldowns) {
                    Ok(finished) => {
                        for id in finished {
                            self.active_reflex_cooldowns.remove(&id);
                        }
                    }
                    Err(e) => tracing::error!(error = ?e, "failed to tick reflexes cooldowns"),
                }
            }
        }

        Ok(AgencyTickReport {
            daemon_reports,
            health_report,
            intents,
            desires,
            duration_ms: t0.elapsed().as_millis() as u64,
        })
    }

    /// Drain KnowledgeGap events from the bus for the desire engine.
    fn drain_gap_events(&mut self) -> Vec<(SectorId, f64, (f32, f32))> {
        let mut gaps = Vec::new();
        loop {
            match self.gap_rx.try_recv() {
                Ok(AgencyEvent::KnowledgeGap { sector, density, suggested_depth_range }) => {
                    gaps.push((sector, density, suggested_depth_range));
                }
                Ok(_) => continue, // skip non-gap events
                Err(tokio::sync::broadcast::error::TryRecvError::Empty) => break,
                Err(tokio::sync::broadcast::error::TryRecvError::Lagged(_)) => continue,
                Err(tokio::sync::broadcast::error::TryRecvError::Closed) => break,
            }
        }
        gaps
    }

    /// Generate TriggerDream intents for high-priority desires.
    ///
    /// For each desire above the threshold, find the nearest node to the
    /// gap sector and create a dream intent from that seed.
    fn generate_dream_intents(
        &self,
        desires: &[DesireSignal],
        storage: &GraphStorage,
    ) -> Vec<AgencyIntent> {
        let threshold = self.config.desire_dream_threshold;
        let depth = self.config.desire_dream_depth;

        // Only process top desire to avoid intent storm
        let top_desire = desires.iter().find(|d| d.priority >= threshold);

        let Some(desire) = top_desire else {
            return Vec::new();
        };

        // Find a seed node near the gap sector
        match find_seed_near_sector(storage, &desire.sector, &desire.depth_range) {
            Some(seed_id) => {
                tracing::info!(
                    desire_id  = %desire.id,
                    seed_node  = %seed_id,
                    priority   = desire.priority,
                    "desire→dream: triggering dream from desire"
                );
                vec![AgencyIntent::TriggerDream {
                    seed_node_id: seed_id,
                    depth,
                    reason: format!(
                        "desire priority={:.2}, sector=({},{}), query={}",
                        desire.priority,
                        desire.sector.depth_bin,
                        desire.sector.angular_bin,
                        desire.suggested_query,
                    ),
                }]
            }
            None => Vec::new(),
        }
    }

    /// Access the event bus for external subscribers.
    pub fn event_bus(&self) -> &AgencyEventBus {
        &self.bus
    }

    /// Ensure the Observer Identity meta-node exists in the graph.
    /// Call this once during initialization.
    pub fn ensure_observer_identity(
        &self,
        storage: &GraphStorage,
    ) -> Result<uuid::Uuid, AgencyError> {
        ObserverIdentity::ensure_exists(storage)
    }
}

/// Find a node near a given gap sector to use as a dream seed.
///
/// Scans NodeMeta (lightweight, no embeddings) and picks the highest-energy
/// node in or adjacent to the target sector. Uses UUID hash for angular bin
/// (same algorithm as the daemons).
fn find_seed_near_sector(
    storage: &GraphStorage,
    sector: &SectorId,
    depth_range: &(f32, f32),
) -> Option<uuid::Uuid> {
    let mut best: Option<(uuid::Uuid, f32)> = None;

    for result in storage.iter_nodes_meta() {
        let meta = match result {
            Ok(m) => m,
            Err(_) => continue,
        };

        // Compute angular bin from UUID hash (same as daemons)
        let mut hasher = DefaultHasher::new();
        meta.id.hash(&mut hasher);
        let hash = hasher.finish();
        let angular_bin = (hash % 16) as usize; // 16 sectors

        // Compute depth bin (5 bins in [0, 1])
        let depth_bin = (meta.depth.clamp(0.0, 0.999) * 5.0) as usize;

        // Check proximity: same or adjacent sector
        let angular_close = angular_bin == sector.angular_bin
            || angular_bin == (sector.angular_bin + 1) % 16
            || angular_bin == (sector.angular_bin + 15) % 16;
        let depth_close = depth_bin == sector.depth_bin
            || (depth_bin > 0 && depth_bin - 1 == sector.depth_bin)
            || depth_bin + 1 == sector.depth_bin;
        // Also accept if depth is in the requested range
        let in_range = meta.depth >= depth_range.0 && meta.depth <= depth_range.1;

        if (angular_close && depth_close) || in_range {
            let is_better = match best {
                None => true,
                Some((_, best_energy)) => meta.energy > best_energy,
            };
            if is_better {
                best = Some((meta.id, meta.energy));
            }
        }
    }

    best.map(|(id, _)| id)
}

#[cfg(test)]
mod tests {
    use super::*;
    use nietzsche_graph::{Edge, EdgeType, GraphStorage, Node, PoincareVector, AdjacencyIndex};
    use tempfile::TempDir;
    use uuid::Uuid;

    fn open_storage(dir: &TempDir) -> GraphStorage {
        GraphStorage::open(dir.path().to_str().unwrap()).unwrap()
    }

    fn make_node(x: f32, y: f32, energy: f32) -> Node {
        let mut node = Node::new(
            Uuid::new_v4(),
            PoincareVector::new(vec![x, y]),
            serde_json::json!({}),
        );
        node.meta.energy = energy;
        node
    }

    #[test]
    fn full_tick_on_star_graph() {
        let dir = TempDir::new().unwrap();
        let storage = open_storage(&dir);
        let adjacency = AdjacencyIndex::new();

        // Star: center -> 10 leaves
        let center = make_node(0.05, 0.0, 0.9);
        let cid = center.id;
        storage.put_node(&center).unwrap();

        for i in 0..10 {
            let angle = i as f32 * std::f32::consts::TAU / 10.0;
            let leaf = make_node(0.4 * angle.cos(), 0.4 * angle.sin(), 0.6);
            let lid = leaf.id;
            storage.put_node(&leaf).unwrap();
            let edge = Edge::new(cid, lid, EdgeType::Association, 0.8);
            storage.put_edge(&edge).unwrap();
            adjacency.add_edge(&edge);
        }

        let config = AgencyConfig {
            observer_report_interval: 1, // report on first tick
            ..AgencyConfig::default()
        };
        let mut engine = AgencyEngine::new(config);
        let report = engine.tick(&storage, &adjacency).unwrap();

        // All daemons should have run
        assert_eq!(report.daemon_reports.len(), 5);
        for dr in &report.daemon_reports {
            assert!(dr.nodes_scanned > 0);
        }

        // Health report should be present (interval=1)
        assert!(report.health_report.is_some());
        let health = report.health_report.as_ref().unwrap();
        assert_eq!(health.total_nodes, 11);
        assert!(health.mean_energy > 0.0);

        // Health report should generate a PersistHealthReport intent
        assert!(report.intents.iter().any(|i| matches!(i, AgencyIntent::PersistHealthReport { .. })));
    }

    #[test]
    fn health_report_at_correct_interval() {
        let dir = TempDir::new().unwrap();
        let storage = open_storage(&dir);
        let adjacency = AdjacencyIndex::new();

        for i in 0..5 {
            let node = make_node(0.01 * (i + 1) as f32, 0.01, 0.5);
            storage.put_node(&node).unwrap();
        }

        let config = AgencyConfig {
            observer_report_interval: 3,
            ..AgencyConfig::default()
        };
        let mut engine = AgencyEngine::new(config);

        // Ticks 1, 2: no health report
        assert!(engine.tick(&storage, &adjacency).unwrap().health_report.is_none());
        assert!(engine.tick(&storage, &adjacency).unwrap().health_report.is_none());

        // Tick 3: health report
        assert!(engine.tick(&storage, &adjacency).unwrap().health_report.is_some());
    }

    #[test]
    fn from_env_creates_engine() {
        let engine = AgencyEngine::from_env();
        assert!(engine.config.tick_secs > 0);
    }

    #[test]
    fn empty_graph_no_panic() {
        let dir = TempDir::new().unwrap();
        let storage = open_storage(&dir);
        let adjacency = AdjacencyIndex::new();

        let config = AgencyConfig {
            observer_report_interval: 1,
            ..AgencyConfig::default()
        };
        let mut engine = AgencyEngine::new(config);
        let report = engine.tick(&storage, &adjacency).unwrap();

        assert_eq!(report.daemon_reports.len(), 5);
        for dr in &report.daemon_reports {
            assert_eq!(dr.nodes_scanned, 0);
        }
    }

    #[test]
    fn low_energy_triggers_sleep_intent() {
        let dir = TempDir::new().unwrap();
        let storage = open_storage(&dir);
        let adjacency = AdjacencyIndex::new();

        // Very low energy nodes
        for i in 0..10 {
            let node = make_node(0.01 * (i + 1) as f32, 0.01, 0.05);
            storage.put_node(&node).unwrap();
        }

        let config = AgencyConfig {
            observer_report_interval: 1,
            observer_wake_energy_threshold: 0.3,
            reactor_cooldown_ticks: 0,
            ..AgencyConfig::default()
        };
        let mut engine = AgencyEngine::new(config);
        let report = engine.tick(&storage, &adjacency).unwrap();

        // Should have a sleep intent from low energy wake-up
        assert!(
            report.intents.iter().any(|i| matches!(i, AgencyIntent::TriggerSleepCycle { .. })),
            "expected TriggerSleepCycle intent for low-energy graph, got: {:?}",
            report.intents
        );
    }

    #[test]
    fn observer_identity_created_on_tick() {
        let dir = TempDir::new().unwrap();
        let storage = open_storage(&dir);
        let adjacency = AdjacencyIndex::new();

        for i in 0..5 {
            let node = make_node(0.01 * (i + 1) as f32, 0.01, 0.6);
            storage.put_node(&node).unwrap();
        }

        let config = AgencyConfig {
            observer_report_interval: 1,
            ..AgencyConfig::default()
        };
        let mut engine = AgencyEngine::new(config);

        // Ensure observer identity is created
        let observer_id = engine.ensure_observer_identity(&storage).unwrap();
        let meta = storage.get_node_meta(&observer_id).unwrap().unwrap();
        assert!(ObserverIdentity::is_observer(&meta));

        // After a tick with health report, observer energy should be updated
        let _report = engine.tick(&storage, &adjacency).unwrap();
        let updated_meta = storage.get_node_meta(&observer_id).unwrap().unwrap();
        assert!(updated_meta.energy > 0.0);
    }
}
