// ─────────────────────────────────────────────────────────
// nql.pest  —  Nietzsche Query Language v2 (PEG grammar)
//
// Operator precedence in conditions (high → low):
//   NOT  >  AND  >  OR
//
// Supported query forms:
//   MATCH (n) WHERE … RETURN …
//   MATCH (a)-[:TYPE]->(b) WHERE … RETURN …
//   DIFFUSE FROM $node WITH t=[…] MAX_HOPS n RETURN …
//   RECONSTRUCT $node_id MODALITY … QUALITY …   (Phase 11)
//   EXPLAIN <any query>
//   INVOKE ZARATUSTRA [IN "col"] [CYCLES n] [ALPHA f] [DECAY f]  (Phase C)
//   BEGIN                                                          (Phase F)
//   COMMIT                                                         (Phase F)
//   ROLLBACK                                                       (Phase F)
// ─────────────────────────────────────────────────────────

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ "--" ~ (!"\n" ~ ANY)* }

// ── Character classes ────────────────────────────────────

ident_tail = _{ ASCII_ALPHANUMERIC | "_" }

// ── Keywords  (silent — do not appear in parse tree) ────

kw_match       = _{ "MATCH"       ~ !ident_tail }
kw_where       = _{ "WHERE"       ~ !ident_tail }
kw_return      = _{ "RETURN"      ~ !ident_tail }
kw_order       = _{ "ORDER"       ~ !ident_tail }
kw_by          = _{ "BY"          ~ !ident_tail }
kw_limit       = _{ "LIMIT"       ~ !ident_tail }
kw_skip        = _{ "SKIP"        ~ !ident_tail }
kw_and         = _{ "AND"         ~ !ident_tail }
kw_or          = _{ "OR"          ~ !ident_tail }
kw_not         = _{ "NOT"         ~ !ident_tail }
kw_in          = _{ "IN"          ~ !ident_tail }
kw_between     = _{ "BETWEEN"     ~ !ident_tail }
kw_distinct    = _{ "DISTINCT"    ~ !ident_tail }
kw_as          = _{ "AS"          ~ !ident_tail }
kw_diffuse     = _{ "DIFFUSE"     ~ !ident_tail }
kw_from        = _{ "FROM"        ~ !ident_tail }
kw_with        = _{ "WITH"        ~ !ident_tail }
kw_max_hops    = _{ "MAX_HOPS"    ~ !ident_tail }
kw_reconstruct = _{ "RECONSTRUCT" ~ !ident_tail }
kw_modality    = _{ "MODALITY"    ~ !ident_tail }
kw_quality     = _{ "QUALITY"     ~ !ident_tail }
kw_group       = _{ "GROUP"       ~ !ident_tail }
kw_explain     = _{ "EXPLAIN"     ~ !ident_tail }
kw_invoke      = _{ "INVOKE"      ~ !ident_tail }
kw_zaratustra  = _{ "ZARATUSTRA"  ~ !ident_tail }
kw_cycles      = _{ "CYCLES"      ~ !ident_tail }
kw_alpha       = _{ "ALPHA"       ~ !ident_tail }
kw_decay       = _{ "DECAY"       ~ !ident_tail }
kw_begin       = _{ "BEGIN"       ~ !ident_tail }
kw_commit      = _{ "COMMIT"      ~ !ident_tail }
kw_rollback    = _{ "ROLLBACK"    ~ !ident_tail }
kw_create      = _{ ^"CREATE"     ~ !ident_tail }
kw_merge       = _{ ^"MERGE"      ~ !ident_tail }
kw_on          = _{ ^"ON"         ~ !ident_tail }
kw_set         = _{ ^"SET"        ~ !ident_tail }

// ── Terminals ────────────────────────────────────────────

integer = @{ ASCII_DIGIT+ }
float   = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string  = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
boolean = @{ ("true" | "false") ~ !ident_tail }
param   = @{ "$" ~ ident_tail+ }
ident   = @{ ASCII_ALPHA ~ ident_tail* }

// Property access: alias.field
// Compound-atomic ($) — no whitespace between the three parts
prop = ${ ident ~ "." ~ ident }

// ── Numeric list  [0.1, 1.0, 10.0] ─────────────────────

number   = { float | integer }
num_list = { "[" ~ number ~ ("," ~ number)* ~ "]" }

// ── Built-in distance functions ─────────────────────────

hdist_arg       = { param | num_list }
hyperbolic_dist = { "HYPERBOLIC_DIST" ~ "(" ~ prop ~ "," ~ hdist_arg ~ ")" }

// Phase 11: sensory distance between a node's latent and a query latent
sdist_arg    = { param }
sensory_dist = { "SENSORY_DIST" ~ "(" ~ prop ~ "," ~ sdist_arg ~ ")" }

// ── Mathematician-named built-in functions ────────────────
//
// These functions honour the mathematicians whose work underpins
// NietzscheDB's hyperbolic geometry, spectral diffusion, and
// graph-theoretic foundations.
//
// Signature categories:
//   dist(prop, arg)      — POINCARE_DIST, KLEIN_DIST, LOBACHEVSKY_ANGLE
//   norm(prop)           — MINKOWSKI_NORM
//   node(alias)          — RIEMANN_CURVATURE, HAUSDORFF_DIM, EULER_CHAR,
//                          LAPLACIAN_SCORE, DIRICHLET_ENERGY, RAMANUJAN_EXPANSION
//   node(alias, scalar)  — GAUSS_KERNEL, CHEBYSHEV_COEFF, FOURIER_COEFF

math_func_name = @{
    ( "POINCARE_DIST"
    | "KLEIN_DIST"
    | "MINKOWSKI_NORM"
    | "LOBACHEVSKY_ANGLE"
    | "RIEMANN_CURVATURE"
    | "GAUSS_KERNEL"
    | "CHEBYSHEV_COEFF"
    | "RAMANUJAN_EXPANSION"
    | "HAUSDORFF_DIM"
    | "EULER_CHAR"
    | "LAPLACIAN_SCORE"
    | "FOURIER_COEFF"
    | "DIRICHLET_ENERGY"
    ) ~ !ident_tail
}

math_func_arg = { param | num_list | number | prop | ident }
math_func     = { math_func_name ~ "(" ~ math_func_arg ~ ("," ~ math_func_arg)* ~ ")" }

// ── Aggregation functions ───────────────────────────────

agg_func_name = @{ ("COUNT" | "SUM" | "AVG" | "MIN" | "MAX") ~ !ident_tail }
star          = { "*" }
agg_arg       = { prop | star | ident }
agg_func      = { agg_func_name ~ "(" ~ agg_arg ~ ")" }

// ── Atom  (leaf operand) ────────────────────────────────

atom = { math_func | hyperbolic_dist | sensory_dist | boolean | float | integer | string | param | prop }

// ── Comparison operators ────────────────────────────────

comp_op = { "<=" | ">=" | "!=" | "<" | ">" | "=" }

// ── String match operators ──────────────────────────────

string_op = @{ ("CONTAINS" | "STARTS_WITH" | "ENDS_WITH") ~ !ident_tail }

// ── Conditions ──────────────────────────────────────────

comparison   = { atom ~ comp_op ~ atom }
in_list      = { "(" ~ atom ~ ("," ~ atom)* ~ ")" }
in_cond      = { atom ~ kw_in ~ in_list }
between_cond = { atom ~ kw_between ~ atom ~ kw_and ~ atom }
string_cond  = { atom ~ string_op ~ atom }
not_cond     = { kw_not ~ primary_cond }
paren_cond   = { "(" ~ or_cond ~ ")" }
primary_cond = { not_cond | paren_cond | in_cond | between_cond | string_cond | comparison }
and_cond     = { primary_cond ~ (kw_and ~ primary_cond)* }
or_cond      = { and_cond ~ (kw_or ~ and_cond)* }
conditions   = { or_cond }
where_clause = { kw_where ~ conditions }

// ── Graph patterns ──────────────────────────────────────

// (alias) or (alias:Label)
node_pattern = { "(" ~ ident ~ (":" ~ ident)? ~ ")" }

// Edge direction — typed or anonymous; optional hop range for variable-length paths
edge_label = @{ ident }
hop_range  = { "*" ~ integer ~ (".." ~ integer)? }
edge_out   = { "-[:" ~ edge_label ~ hop_range? ~ "]->" | "-->" }
edge_in    = { "<-[:" ~ edge_label ~ hop_range? ~ "]-" | "<--" }
edge_dir   = { edge_out | edge_in }

// (a)-[:TYPE]->(b) or (a)-->(b)
path_pattern = { node_pattern ~ edge_dir ~ node_pattern }

// Either a path or a lone node
pattern      = { path_pattern | node_pattern }
match_clause = { kw_match ~ pattern }

// ── RETURN ──────────────────────────────────────────────

// ORDER BY expr [ASC|DESC]
order_dir  = { "DESC" | "ASC" }
order_expr = { math_func | hyperbolic_dist | sensory_dist | prop | ident }
order_by   = { kw_order ~ kw_by ~ order_expr ~ order_dir? }

// LIMIT n / SKIP n
limit_clause = { kw_limit ~ integer }
skip_clause  = { kw_skip ~ integer }

// Items: n, n.energy, COUNT(n.energy), n.energy AS e
as_alias     = { kw_as ~ ident }
return_item  = { (agg_func | prop | ident) ~ as_alias? }

// GROUP BY
group_by_item = { prop | ident }
group_by      = { kw_group ~ kw_by ~ group_by_item ~ ("," ~ group_by_item)* }

// DISTINCT marker (non-silent so we detect its presence)
distinct_kw = { kw_distinct }

return_clause = {
    kw_return ~ distinct_kw?
    ~ return_item ~ ("," ~ return_item)*
    ~ group_by?
    ~ order_by?
    ~ limit_clause?
    ~ skip_clause?
}

// ── DIFFUSE query ───────────────────────────────────────

diffuse_from  = { param | ident }
diffuse_t     = { kw_with ~ "t" ~ "=" ~ num_list }
diffuse_hops  = { kw_max_hops ~ integer }
diffuse_query = {
    kw_diffuse ~ kw_from ~ diffuse_from
    ~ diffuse_t?
    ~ diffuse_hops?
    ~ return_clause?
}

// ── MERGE patterns ─────────────────────────────────────

prop_pair          = { ident ~ ":" ~ atom }
prop_map           = { "{" ~ prop_pair ~ ("," ~ prop_pair)* ~ "}" }
merge_node_pattern = { "(" ~ ident ~ (":" ~ ident)? ~ prop_map? ~ ")" }
merge_edge_pattern = { merge_node_pattern ~ edge_dir ~ merge_node_pattern }
merge_pattern      = { merge_edge_pattern | merge_node_pattern }

set_assignment   = { prop ~ "=" ~ atom }
set_clause       = { kw_set ~ set_assignment ~ ("," ~ set_assignment)* }
on_create_clause = { kw_on ~ kw_create ~ set_clause }
on_match_clause  = { kw_on ~ kw_match ~ set_clause }

merge_query = {
    kw_merge ~ merge_pattern
    ~ on_create_clause?
    ~ on_match_clause?
    ~ return_clause?
}

// ── MATCH query ─────────────────────────────────────────

match_query = {
    match_clause
    ~ where_clause?
    ~ return_clause
}

// ── RECONSTRUCT query (Phase 11) ────────────────────────

reconstruct_target  = { param | ident }
modality_name       = @{ ident }
quality_level       = @{ ident }
reconstruct_query   = {
    kw_reconstruct ~ reconstruct_target
    ~ (kw_modality ~ modality_name)?
    ~ (kw_quality  ~ quality_level)?
}

// ── EXPLAIN query ───────────────────────────────────────

explain_query = { kw_explain ~ (reconstruct_query | diffuse_query | match_query) }

// ── INVOKE ZARATUSTRA query (Phase C) ───────────────────
//
// Examples:
//   INVOKE ZARATUSTRA
//   INVOKE ZARATUSTRA IN "memories" CYCLES 3 ALPHA 0.15 DECAY 0.01

zaratustra_in     = { kw_in ~ string }
zaratustra_cycles = { kw_cycles ~ integer }
zaratustra_alpha  = { kw_alpha  ~ float }
zaratustra_decay  = { kw_decay  ~ float }

invoke_zaratustra_query = {
    kw_invoke ~ kw_zaratustra
    ~ zaratustra_in?
    ~ zaratustra_cycles?
    ~ zaratustra_alpha?
    ~ zaratustra_decay?
}

// ── Transaction control queries (Phase F) ───────────────

begin_tx_query    = { kw_begin }
commit_tx_query   = { kw_commit }
rollback_tx_query = { kw_rollback }

// ── Top-level ───────────────────────────────────────────

query = { SOI ~ (explain_query | invoke_zaratustra_query | begin_tx_query | commit_tx_query | rollback_tx_query | reconstruct_query | diffuse_query | merge_query | match_query) ~ EOI }
