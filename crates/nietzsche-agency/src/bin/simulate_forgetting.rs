//! Simulation: O Grande Motor do Esquecimento — Fase Clinica
//!
//! Runs the Nezhmetdinov Forgetting Engine on a synthetic universe of 5,000 nodes
//! (1,000 Signal + 4,000 Noise) for 500 accelerated Zaratustra cycles.
//!
//! ## 4 Vital Signs tracked:
//! 1. **TGC** — Topological Generative Capacity (fertility from forgetting)
//! 2. **Var(V)** — Vitality Variance (cognitive health / diversity)
//! 3. **Elite Drift** — Centroid displacement (identity preservation)
//! 4. **Sacrifices/cycle** — Hard deletes per cycle
//!
//! ## Usage
//! ```sh
//! cargo run --release --bin simulate_forgetting
//! ```
//!
//! ## Output
//! CSV file `forgetting_telemetry.csv` with per-cycle vital signs.

use std::fs::OpenOptions;
use std::io::Write;
use uuid::Uuid;

/// Sigmoid function: sigma(z) = 1 / (1 + e^(-z))
fn sigmoid(z: f32) -> f32 {
    1.0 / (1.0 + (-z).exp())
}

/// Vitality weights from the Nezhmetdinov spec.
struct VitalityWeights {
    w1_energy: f32,
    w2_hausdorff: f32,
    w3_entropy: f32,
    w4_elite_prox: f32,
    w5_causal: f32,
    w6_toxicity: f32,
}

impl Default for VitalityWeights {
    fn default() -> Self {
        Self {
            w1_energy: 1.0,
            w2_hausdorff: 0.8,
            w3_entropy: 1.2,
            w4_elite_prox: 1.5,
            w5_causal: 2.0,
            w6_toxicity: 1.0,
        }
    }
}

/// A simulated node in RAM.
#[derive(Clone)]
struct SimNode {
    _id: Uuid,
    energy: f32,
    hausdorff: f32,
    entropy_delta: f32,
    elite_proximity: f32,
    causal_edges: usize,
    toxicity: f32,
    is_signal: bool,
    /// Poincare coordinates for elite drift tracking (simplified 2D).
    px: f32,
    py: f32,
}

/// Telemetry for one cycle — includes all 4 vital signs.
struct CycleTelemetry {
    cycle: usize,
    total_nodes: usize,
    sacrificed: usize,
    signal_killed_total: usize,
    noise_killed_total: usize,
    mean_vitality: f32,
    variance_vitality: f32,
    mean_energy: f32,
    tgc: f32,
    elite_drift: f32,
}

/// Elite centroid snapshot for drift tracking.
#[derive(Clone, Copy)]
struct EliteCentroid {
    cx: f32,
    cy: f32,
    count: usize,
}

impl EliteCentroid {
    fn zero() -> Self {
        Self { cx: 0.0, cy: 0.0, count: 0 }
    }

    fn distance(&self, other: &EliteCentroid) -> f32 {
        let dx = self.cx - other.cx;
        let dy = self.cy - other.cy;
        (dx * dx + dy * dy).sqrt()
    }
}

/// TGC tracker with EMA smoothing.
struct TgcTracker {
    prev_total: usize,
    generation_count: usize,
    ema: f32,
    alpha: f32,
}

impl TgcTracker {
    fn new(initial_total: usize) -> Self {
        Self {
            prev_total: initial_total,
            generation_count: 0,
            ema: 0.5,
            alpha: 0.3,
        }
    }

    /// Update TGC after a cycle.
    /// TGC(t) = (G_t / V_t) * Quality where:
    /// - G_t = new nodes generated (0 in pure forgetting, but we simulate regrowth)
    /// - V_t = total nodes
    /// - Quality = mean_vitality of survivors
    fn update(&mut self, current_total: usize, deleted: usize, mean_vitality: f32) -> f32 {
        // In a real system, new nodes would be generated by the L-System.
        // For simulation, we model regrowth as proportional to void count.
        // Regrowth potential = min(deleted * 0.3, 50) nodes that COULD be generated.
        let regrowth_potential = (deleted as f32 * 0.3).min(50.0);
        self.generation_count += regrowth_potential as usize;

        let v_t = current_total.max(1) as f32;
        let g_t = regrowth_potential;
        let quality = mean_vitality.clamp(0.0, 1.0);

        let raw_tgc = (g_t / v_t) * quality;

        // EMA smoothing
        self.ema = self.alpha * raw_tgc + (1.0 - self.alpha) * self.ema;
        self.prev_total = current_total;

        self.ema
    }
}

/// The Forgetting Simulator — runs entirely in RAM.
struct ForgettingSimulator {
    weights: VitalityWeights,
    graph: Vec<SimNode>,
    noise_killed: usize,
    signal_killed: usize,
    vitality_threshold: f32,
    energy_threshold: f32,
    tgc_tracker: TgcTracker,
    initial_centroid: EliteCentroid,
}

impl ForgettingSimulator {
    fn new() -> Self {
        Self {
            weights: VitalityWeights::default(),
            graph: Vec::new(),
            noise_killed: 0,
            signal_killed: 0,
            vitality_threshold: 0.30,
            energy_threshold: 0.10,
            tgc_tracker: TgcTracker::new(5000),
            initial_centroid: EliteCentroid::zero(),
        }
    }

    /// Seed 5,000 nodes: 1,000 Signal + 4,000 Noise.
    fn seed_synthetic_graph(&mut self) {
        let mut seed: u64 = 42;
        let mut next_f32 = |lo: f32, hi: f32| -> f32 {
            seed = seed.wrapping_mul(6364136223846793005).wrapping_add(1442695040888963407);
            let t = ((seed >> 33) as f32) / (u32::MAX as f32);
            lo + t * (hi - lo)
        };

        // 1,000 Signal nodes (high energy, causal anchoring)
        for _ in 0..1000 {
            self.graph.push(SimNode {
                _id: Uuid::new_v4(),
                energy: next_f32(0.6, 1.0),
                hausdorff: next_f32(0.6, 1.2),
                entropy_delta: next_f32(0.0, 0.2),
                elite_proximity: next_f32(0.0, 0.3),
                causal_edges: 3,
                toxicity: next_f32(0.0, 0.1),
                is_signal: true,
                px: next_f32(-0.3, 0.3),  // Near center (shallow Poincare depth)
                py: next_f32(-0.3, 0.3),
            });
        }

        // 4,000 Noise nodes (low energy, no causal anchoring)
        for _ in 0..4000 {
            self.graph.push(SimNode {
                _id: Uuid::new_v4(),
                energy: next_f32(0.0, 0.25),
                hausdorff: next_f32(0.05, 0.3),
                entropy_delta: next_f32(0.5, 1.0),
                elite_proximity: next_f32(0.7, 1.0),
                causal_edges: 0,
                toxicity: next_f32(0.3, 0.8),
                is_signal: false,
                px: next_f32(-0.9, 0.9),  // Spread across disk
                py: next_f32(-0.9, 0.9),
            });
        }

        // Capture initial elite centroid
        self.initial_centroid = self.compute_elite_centroid();
        self.tgc_tracker = TgcTracker::new(self.graph.len());
    }

    /// Compute centroid of elite nodes (top 20% by energy).
    fn compute_elite_centroid(&self) -> EliteCentroid {
        if self.graph.is_empty() {
            return EliteCentroid::zero();
        }

        let mut energies: Vec<f32> = self.graph.iter().map(|n| n.energy).collect();
        energies.sort_by(|a, b| b.partial_cmp(a).unwrap());
        let top_20_threshold = energies[energies.len() / 5]; // Top 20%

        let mut sum_x = 0.0f32;
        let mut sum_y = 0.0f32;
        let mut count = 0usize;

        for node in &self.graph {
            if node.energy >= top_20_threshold {
                sum_x += node.px;
                sum_y += node.py;
                count += 1;
            }
        }

        if count == 0 {
            return EliteCentroid::zero();
        }

        EliteCentroid {
            cx: sum_x / count as f32,
            cy: sum_y / count as f32,
            count,
        }
    }

    /// Calculate V(n) for a node.
    fn vitality(&self, node: &SimNode) -> f32 {
        let w = &self.weights;
        let prox_score = (1.0 - node.elite_proximity).max(0.0);
        let z = w.w1_energy * node.energy
              + w.w2_hausdorff * node.hausdorff
              - w.w3_entropy * node.entropy_delta
              + w.w4_elite_prox * prox_score
              + w.w5_causal * node.causal_edges as f32
              - w.w6_toxicity * node.toxicity;
        sigmoid(z)
    }

    /// Run one Zaratustra cycle with full telemetry.
    fn run_cycle(&mut self, cycle_id: usize) -> CycleTelemetry {
        let mut sacrificed = 0usize;
        let mut vitalities = Vec::with_capacity(self.graph.len());
        let mut surviving = Vec::with_capacity(self.graph.len());
        let mut energy_sum = 0.0f32;

        for node in &self.graph {
            let v = self.vitality(node);
            vitalities.push(v);
            energy_sum += node.energy;

            // Triple Condition
            let cond1 = v < self.vitality_threshold;
            let cond2 = node.energy < self.energy_threshold;
            let cond3 = node.causal_edges == 0;

            // Toxic fast-track
            let toxic = node.toxicity > 0.8 && node.causal_edges == 0;

            if (cond1 && cond2 && cond3) || toxic {
                sacrificed += 1;
                if node.is_signal {
                    self.signal_killed += 1;
                } else {
                    self.noise_killed += 1;
                }
            } else {
                surviving.push(node.clone());
            }
        }

        let total_before = self.graph.len();
        self.graph = surviving;

        // ── Vital Sign 1: Vitality Statistics ──
        let n = vitalities.len().max(1) as f32;
        let mean_v: f32 = vitalities.iter().sum::<f32>() / n;
        let var_v: f32 = vitalities.iter()
            .map(|v| (v - mean_v).powi(2))
            .sum::<f32>() / n;
        let mean_e = energy_sum / total_before.max(1) as f32;

        // ── Vital Sign 2: TGC ──
        let tgc = self.tgc_tracker.update(self.graph.len(), sacrificed, mean_v);

        // ── Vital Sign 3: Elite Drift ──
        let current_centroid = self.compute_elite_centroid();
        let elite_drift = self.initial_centroid.distance(&current_centroid);

        CycleTelemetry {
            cycle: cycle_id,
            total_nodes: self.graph.len(),
            sacrificed,
            signal_killed_total: self.signal_killed,
            noise_killed_total: self.noise_killed,
            mean_vitality: mean_v,
            variance_vitality: var_v,
            mean_energy: mean_e,
            tgc,
            elite_drift,
        }
    }
}

fn main() {
    println!("==========================================================");
    println!("  O GRANDE MOTOR DO ESQUECIMENTO - Nezhmetdinov Simulator");
    println!("  NietzscheDB Active Forgetting Engine — Fase Clinica");
    println!("  4 Sinais Vitais x 500 Ciclos Zaratustra");
    println!("==========================================================");
    println!();

    let mut sim = ForgettingSimulator::new();
    sim.seed_synthetic_graph();

    println!("Universo semeado: {} nos ({} sinal, {} ruido)",
        sim.graph.len(),
        sim.graph.iter().filter(|n| n.is_signal).count(),
        sim.graph.iter().filter(|n| !n.is_signal).count(),
    );
    println!("Elite centroid inicial: ({:.4}, {:.4})",
        sim.initial_centroid.cx, sim.initial_centroid.cy);
    println!();

    let csv_path = "forgetting_telemetry.csv";
    let mut file = OpenOptions::new()
        .write(true).create(true).truncate(true)
        .open(csv_path).unwrap();
    writeln!(file, "cycle,total_nodes,sacrificed,signal_killed,noise_killed,mean_vitality,variance_vitality,mean_energy,tgc,elite_drift").unwrap();

    let total_cycles = 500;

    for i in 1..=total_cycles {
        let t = sim.run_cycle(i);

        // Write CSV — all 4 vital signs
        writeln!(file, "{},{},{},{},{},{:.6},{:.6},{:.6},{:.6},{:.6}",
            t.cycle, t.total_nodes, t.sacrificed,
            t.signal_killed_total, t.noise_killed_total,
            t.mean_vitality, t.variance_vitality, t.mean_energy,
            t.tgc, t.elite_drift,
        ).unwrap();

        // Console output (every 10 cycles or first/last)
        if i <= 5 || i % 25 == 0 || i == total_cycles || t.total_nodes < 100 {
            println!(
                "Ciclo {:03} | Nos: {:5} | Sacr: {:4} | FP: {} | V={:.3} Var={:.4} | E={:.3} | TGC={:.4} | Drift={:.4}",
                i, t.total_nodes, t.sacrificed,
                t.signal_killed_total, t.mean_vitality, t.variance_vitality,
                t.mean_energy, t.tgc, t.elite_drift,
            );
        }

        if t.total_nodes < 100 {
            println!();
            println!("[ALERTA] COLAPSO MINIMALISTA no ciclo {}! Universo esgotado.", i);
            break;
        }
    }

    println!();
    println!("==========================================================");
    println!("  RESULTADO FINAL — AUTOPSIA DO METABOLISMO");
    println!("==========================================================");
    println!("  Nos sobreviventes: {}", sim.graph.len());
    println!("  Sinal sobrevivente: {}", sim.graph.iter().filter(|n| n.is_signal).count());
    println!("  Ruido sobrevivente: {}", sim.graph.iter().filter(|n| !n.is_signal).count());
    println!("  Sinal morto (Falsos Positivos): {}", sim.signal_killed);
    println!("  Ruido morto (Verdadeiros Positivos): {}", sim.noise_killed);
    println!("  Elite drift final: {:.6}", sim.initial_centroid.distance(&sim.compute_elite_centroid()));
    println!("  Telemetria: {}", csv_path);
    println!();

    // ── Validation ──
    let final_signal = sim.graph.iter().filter(|n| n.is_signal).count();
    let final_noise = sim.graph.iter().filter(|n| !n.is_signal).count();

    if sim.signal_killed == 0 {
        println!("  [OK] HIPOTESE VALIDADA: Zero falsos positivos!");
        println!("       O esquecimento ativo preservou 100% das elites.");
    } else {
        println!("  [!!] ATENCAO: {} nos de sinal foram mortos.", sim.signal_killed);
        println!("       A funcao de vitalidade precisa de ajuste.");
    }

    if final_noise == 0 && final_signal > 900 {
        println!("  [OK] CONVERGENCIA TOTAL: Todo ruido eliminado, sinal intacto.");
    } else if final_noise < 100 {
        println!("  [OK] CONVERGENCIA PARCIAL: Ruido residual = {} nos.", final_noise);
    }

    let drift = sim.initial_centroid.distance(&sim.compute_elite_centroid());
    if drift < 0.1 {
        println!("  [OK] IDENTIDADE PRESERVADA: Elite drift = {:.4} < 0.1", drift);
    } else {
        println!("  [!!] ALERTA DRIFT: Elite drift = {:.4} >= 0.1", drift);
    }

    println!();
    println!("  Rode: python plot_metabolism.py");
    println!("  Para gerar o dashboard de 4 quadrantes.");
    println!();
    println!("  \"O que e grande no homem e que ele e uma ponte e nao um fim.\"");
    println!("  -- Friedrich Nietzsche, Assim Falou Zaratustra");
    println!("==========================================================");
}
