//! Wiederkehr Daemon Engine — ticks through all daemon definitions,
//! evaluates WHEN conditions against matching nodes, collects intents.

use uuid::Uuid;
use nietzsche_graph::GraphStorage;

use crate::config::DaemonEngineConfig;
use crate::error::DaemonError;
use crate::evaluator::evaluate_condition;
use crate::model::DaemonDef;
use crate::store;

/// Intent generated by a daemon tick — executed by the server under write lock.
#[derive(Debug, Clone)]
pub enum DaemonIntent {
    /// Delete a node.
    DeleteNode(Uuid),
    /// Set fields on a node.
    SetNodeFields { node_id: Uuid, fields: serde_json::Value },
    /// Trigger a diffusion walk from a node.
    DiffuseFromNode { node_id: Uuid, t_values: Vec<f64>, max_hops: usize },
}

/// Result of a single daemon engine tick.
#[derive(Debug, Default)]
pub struct DaemonTickResult {
    /// Human-readable report of what happened.
    pub report: Vec<String>,
    /// Intents to be executed by the server.
    pub intents: Vec<DaemonIntent>,
    /// Names of daemons that were reaped (energy depleted).
    pub reaped: Vec<String>,
}

/// The daemon engine. Stateless — all state lives in CF_META.
pub struct DaemonEngine {
    pub config: DaemonEngineConfig,
}

impl DaemonEngine {
    pub fn new(config: DaemonEngineConfig) -> Self {
        Self { config }
    }

    /// Run one tick: scan daemons, evaluate conditions, collect intents.
    ///
    /// This runs under a **read lock** — it does NOT mutate the graph.
    /// The returned intents must be executed by the server under a write lock.
    pub fn tick(
        &self,
        storage: &GraphStorage,
    ) -> Result<DaemonTickResult, DaemonError> {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs_f64();

        let daemons = store::list_daemons(storage)?;
        let mut result = DaemonTickResult::default();

        if daemons.is_empty() {
            return Ok(result);
        }

        for mut daemon in daemons {
            // Skip daemons that aren't due yet
            if !daemon.is_due(now) {
                continue;
            }

            result.report.push(format!("daemon '{}' tick (energy={:.3})", daemon.name, daemon.energy));

            // Scan nodes matching the daemon's ON pattern
            let label_filter = daemon.on_pattern.label.as_deref();
            let alias = &daemon.on_pattern.alias;

            let mut count = 0;
            let iter = storage.iter_nodes_meta();
            for meta_result in iter {
                if count >= self.config.max_nodes_per_tick {
                    break;
                }
                let meta = match meta_result {
                    Ok(m) => m,
                    Err(_) => continue,
                };

                // Label filter
                if let Some(label) = label_filter {
                    if format!("{:?}", meta.node_type) != label {
                        continue;
                    }
                }

                count += 1;

                // Build a lightweight Node for evaluation (no embedding needed)
                let node = nietzsche_graph::Node {
                    meta,
                    embedding: nietzsche_graph::PoincareVector::origin(1),
                };

                // Evaluate WHEN condition
                match evaluate_condition(&daemon.when_cond, &node, alias) {
                    Ok(true) => {
                        // Generate intents from THEN action
                        let intents = action_to_intents(&daemon, node.meta.id);
                        result.intents.extend(intents);
                    }
                    Ok(false) => {}
                    Err(e) => {
                        result.report.push(format!(
                            "daemon '{}' eval error on node {}: {}", daemon.name, node.meta.id, e
                        ));
                    }
                }
            }

            // Decay energy
            daemon.energy = (daemon.energy - self.config.decay_per_tick).max(0.0);
            daemon.last_run = now;

            // Reap if energy depleted
            if daemon.energy < self.config.min_energy {
                result.report.push(format!("daemon '{}' reaped (energy={:.4})", daemon.name, daemon.energy));
                result.reaped.push(daemon.name.clone());
                store::delete_daemon(storage, &daemon.name)?;
            } else {
                // Persist updated energy + last_run
                store::put_daemon(storage, &daemon)?;
            }
        }

        Ok(result)
    }
}

fn action_to_intents(daemon: &DaemonDef, node_id: Uuid) -> Vec<DaemonIntent> {
    use nietzsche_query::ast::DaemonAction;
    match &daemon.then_action {
        DaemonAction::Delete { .. } => {
            vec![DaemonIntent::DeleteNode(node_id)]
        }
        DaemonAction::Set { assignments } => {
            let mut fields = serde_json::Map::new();
            for a in assignments {
                let val = expr_to_json(&a.value);
                fields.insert(a.field.clone(), val);
            }
            vec![DaemonIntent::SetNodeFields {
                node_id,
                fields: serde_json::Value::Object(fields),
            }]
        }
        DaemonAction::Diffuse { t_values, max_hops, .. } => {
            vec![DaemonIntent::DiffuseFromNode {
                node_id,
                t_values: t_values.clone(),
                max_hops: *max_hops,
            }]
        }
    }
}

fn expr_to_json(expr: &nietzsche_query::ast::Expr) -> serde_json::Value {
    match expr {
        nietzsche_query::ast::Expr::Float(f) => serde_json::json!(f),
        nietzsche_query::ast::Expr::Int(i)   => serde_json::json!(i),
        nietzsche_query::ast::Expr::Str(s)   => serde_json::json!(s),
        nietzsche_query::ast::Expr::Bool(b)  => serde_json::json!(b),
        _ => serde_json::Value::Null,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::store;
    use nietzsche_query::ast::*;

    fn temp_storage() -> (tempfile::TempDir, GraphStorage) {
        let dir = tempfile::tempdir().unwrap();
        let storage = GraphStorage::open(dir.path().to_str().unwrap()).unwrap();
        (dir, storage)
    }

    fn sample_daemon(name: &str, energy: f64, interval: f64, last_run: f64) -> DaemonDef {
        DaemonDef {
            name: name.to_string(),
            on_pattern: NodePattern { alias: "n".into(), label: None },
            when_cond: Condition::Compare {
                left:  Expr::Property { alias: "n".into(), field: "energy".into() },
                op:    CompOp::Gt,
                right: Expr::Float(0.5),
            },
            then_action: DaemonAction::Delete { alias: "n".into() },
            every: Expr::Float(interval),
            energy,
            last_run,
            interval_secs: interval,
        }
    }

    #[test]
    fn tick_empty_no_daemons() {
        let (_dir, storage) = temp_storage();
        let engine = DaemonEngine::new(DaemonEngineConfig::default());
        let result = engine.tick(&storage).unwrap();
        assert!(result.intents.is_empty());
        assert!(result.report.is_empty());
    }

    #[test]
    fn tick_not_due_skips() {
        let (_dir, storage) = temp_storage();
        // Daemon ran 5 seconds ago with 3600s interval — not due
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();
        let daemon = sample_daemon("watcher", 1.0, 3600.0, now - 5.0);
        store::put_daemon(&storage, &daemon).unwrap();

        let engine = DaemonEngine::new(DaemonEngineConfig::default());
        let result = engine.tick(&storage).unwrap();
        assert!(result.intents.is_empty());
    }

    #[test]
    fn tick_due_executes() {
        let (_dir, storage) = temp_storage();
        // Daemon hasn't run (last_run=0), interval=1s → definitely due
        let daemon = sample_daemon("reaper", 1.0, 1.0, 0.0);
        store::put_daemon(&storage, &daemon).unwrap();

        // Insert a node with energy > 0.5 so the WHEN condition fires
        let node = nietzsche_graph::Node {
            meta: nietzsche_graph::NodeMeta {
                id: uuid::Uuid::new_v4(),
                node_type: nietzsche_graph::NodeType::Semantic,
                energy: 0.9,
                depth: 0.5,
                created_at: 1000,
                content: serde_json::json!({}),
                lsystem_generation: 0,
                hausdorff_local: 1.0,
                expires_at: None,
                metadata: std::collections::HashMap::new(),
            },
            embedding: nietzsche_graph::PoincareVector::origin(8),
        };
        storage.put_node(&node).unwrap();

        let engine = DaemonEngine::new(DaemonEngineConfig::default());
        let result = engine.tick(&storage).unwrap();
        assert!(!result.intents.is_empty(), "expected at least one intent");
        assert!(matches!(result.intents[0], DaemonIntent::DeleteNode(_)));
    }

    #[test]
    fn tick_reaps_dead_daemon() {
        let (_dir, storage) = temp_storage();
        // Daemon with energy just above threshold, decay will push it below
        let cfg = DaemonEngineConfig {
            decay_per_tick: 0.05,
            min_energy: 0.01,
            ..Default::default()
        };
        let daemon = sample_daemon("dying", 0.02, 1.0, 0.0);
        store::put_daemon(&storage, &daemon).unwrap();

        let engine = DaemonEngine::new(cfg);
        let result = engine.tick(&storage).unwrap();
        assert!(result.reaped.contains(&"dying".to_string()));
        // Daemon should be gone from store
        assert!(store::get_daemon(&storage, "dying").unwrap().is_none());
    }

    #[test]
    fn tick_decays_energy() {
        let (_dir, storage) = temp_storage();
        let cfg = DaemonEngineConfig {
            decay_per_tick: 0.1,
            min_energy: 0.01,
            ..Default::default()
        };
        let daemon = sample_daemon("healthy", 1.0, 1.0, 0.0);
        store::put_daemon(&storage, &daemon).unwrap();

        let engine = DaemonEngine::new(cfg);
        engine.tick(&storage).unwrap();

        let updated = store::get_daemon(&storage, "healthy").unwrap().unwrap();
        assert!((updated.energy - 0.9).abs() < 0.001, "energy should have decayed to ~0.9, got {}", updated.energy);
    }
}
