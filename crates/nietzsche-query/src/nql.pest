// ─────────────────────────────────────────────────────────
// nql.pest  —  Nietzsche Query Language v2 (PEG grammar)
//
// Operator precedence in conditions (high → low):
//   NOT  >  AND  >  OR
//
// Supported query forms:
//   MATCH (n) WHERE … RETURN …
//   MATCH (a)-[:TYPE]->(b) WHERE … RETURN …
//   DIFFUSE FROM $node WITH t=[…] MAX_HOPS n RETURN …
//   RECONSTRUCT $node_id MODALITY … QUALITY …   (Phase 11)
//   EXPLAIN <any query>
//   INVOKE ZARATUSTRA [IN "col"] [CYCLES n] [ALPHA f] [DECAY f]  (Phase C)
//   BEGIN                                                          (Phase F)
//   COMMIT                                                         (Phase F)
//   ROLLBACK                                                       (Phase F)
// ─────────────────────────────────────────────────────────

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ "--" ~ !(">") ~ (!"\n" ~ ANY)* }

// ── Character classes ────────────────────────────────────

ident_tail = _{ ASCII_ALPHANUMERIC | "_" }

// ── Keywords  (silent — do not appear in parse tree) ────

kw_match       = _{ "MATCH"       }
kw_where       = _{ "WHERE"       }
kw_return      = _{ "RETURN"      }
kw_order       = _{ "ORDER"       }
kw_by          = _{ "BY"          }
kw_limit       = _{ "LIMIT"       }
kw_skip        = _{ "SKIP"        }
kw_and         = _{ "AND"         }
kw_or          = _{ "OR"          }
kw_not         = _{ "NOT"         }
kw_in          = _{ "IN"          }
kw_between     = _{ "BETWEEN"     }
kw_distinct    = _{ "DISTINCT"    }
kw_as          = _{ "AS"          }
kw_diffuse     = _{ "DIFFUSE"     }
kw_from        = _{ "FROM"        }
kw_with        = _{ "WITH"        }
kw_max_hops    = _{ "MAX_HOPS"    }
kw_reconstruct = _{ "RECONSTRUCT" }
kw_modality    = _{ "MODALITY"    }
kw_quality     = _{ "QUALITY"     }
kw_group       = _{ "GROUP"       }
kw_explain     = _{ "EXPLAIN"     }
kw_invoke      = _{ "INVOKE"      }
kw_zaratustra  = _{ "ZARATUSTRA"  }
kw_cycles      = _{ "CYCLES"      }
kw_alpha       = _{ "ALPHA"       }
kw_decay       = _{ "DECAY"       }
kw_begin       = _{ "BEGIN"       }
kw_commit      = _{ "COMMIT"      }
kw_rollback    = _{ "ROLLBACK"    }
kw_create      = _{ ^"CREATE"     }
kw_merge       = _{ ^"MERGE"      }
kw_on          = _{ ^"ON"         }
kw_set         = _{ ^"SET"        }
kw_delete      = _{ ^"DELETE"     }
kw_daemon      = _{ ^"DAEMON"     }
kw_daemons     = _{ ^"DAEMONS"    }
kw_when        = _{ ^"WHEN"       }
kw_then        = _{ ^"THEN"       }
kw_every       = _{ ^"EVERY"      }
kw_energy      = _{ ^"ENERGY"     }
kw_show        = _{ ^"SHOW"       }
kw_drop        = _{ ^"DROP"       }
kw_dream       = _{ ^"DREAM"     }
kw_dreams      = _{ ^"DREAMS"    }
kw_apply       = _{ ^"APPLY"     }
kw_reject      = _{ ^"REJECT"    }
kw_depth       = _{ ^"DEPTH"     }
kw_noise       = _{ ^"NOISE"     }
kw_translate   = _{ ^"TRANSLATE" }
kw_to          = _{ ^"TO"        }
kw_counterfactual = _{ ^"COUNTERFACTUAL" }
kw_as_of       = _{ ^"AS" ~ ^"OF" }
kw_cycle       = _{ ^"CYCLE"     }
kw_archetypes  = _{ ^"ARCHETYPES" }
kw_share       = _{ ^"SHARE"     }
kw_archetype   = _{ ^"ARCHETYPE" }
kw_narrate     = _{ ^"NARRATE"   }
kw_window      = _{ ^"WINDOW"    }
kw_format      = _{ ^"FORMAT"    }

// ── Terminals ────────────────────────────────────────────

integer = @{ ASCII_DIGIT+ }
float   = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string  = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
boolean = @{ ("true" | "false") ~ !ident_tail }
param   = @{ "$" ~ ident_tail+ }
ident   = @{ ASCII_ALPHA ~ ident_tail* }

// Property access: alias.field
// Compound-atomic ($) — no whitespace between the three parts
prop = ${ ident ~ "." ~ ident }

// ── Numeric list  [0.1, 1.0, 10.0] ─────────────────────

number   = { float | integer }
num_list = { "[" ~ number ~ ("," ~ number)* ~ "]" }

// ── Built-in distance functions ─────────────────────────

hdist_arg       = { param | num_list }
hyperbolic_dist = { "HYPERBOLIC_DIST" ~ "(" ~ prop ~ "," ~ hdist_arg ~ ")" }

// Phase 11: sensory distance between a node's latent and a query latent
sdist_arg    = { param }
sensory_dist = { "SENSORY_DIST" ~ "(" ~ prop ~ "," ~ sdist_arg ~ ")" }

// ── Mathematician-named built-in functions ────────────────
//
// These functions honour the mathematicians whose work underpins
// NietzscheDB's hyperbolic geometry, spectral diffusion, and
// graph-theoretic foundations.
//
// Signature categories:
//   dist(prop, arg)      — POINCARE_DIST, KLEIN_DIST, LOBACHEVSKY_ANGLE
//   norm(prop)           — MINKOWSKI_NORM
//   node(alias)          — RIEMANN_CURVATURE, HAUSDORFF_DIM, EULER_CHAR,
//                          LAPLACIAN_SCORE, DIRICHLET_ENERGY, RAMANUJAN_EXPANSION
//   node(alias, scalar)  — GAUSS_KERNEL, CHEBYSHEV_COEFF, FOURIER_COEFF

math_func_name = @{
    ( "POINCARE_DIST"
    | "KLEIN_DIST"
    | "MINKOWSKI_NORM"
    | "LOBACHEVSKY_ANGLE"
    | "RIEMANN_CURVATURE"
    | "GAUSS_KERNEL"
    | "CHEBYSHEV_COEFF"
    | "RAMANUJAN_EXPANSION"
    | "HAUSDORFF_DIM"
    | "EULER_CHAR"
    | "LAPLACIAN_SCORE"
    | "FOURIER_COEFF"
    | "DIRICHLET_ENERGY"
    | "NOW"
    | "EPOCH_MS"
    | "INTERVAL"
    ) ~ !ident_tail
}

math_func_arg = { param | num_list | number | string | prop | ident }
math_func     = { math_func_name ~ "(" ~ (math_func_arg ~ ("," ~ math_func_arg)*)? ~ ")" }

// ── Aggregation functions ───────────────────────────────

agg_func_name = @{ ("COUNT" | "SUM" | "AVG" | "MIN" | "MAX") ~ !ident_tail }
star          = { "*" }
agg_arg       = { prop | star | ident }
agg_func      = { agg_func_name ~ "(" ~ agg_arg ~ ")" }

// ── Atom  (leaf operand) ────────────────────────────────

atom = { math_func | hyperbolic_dist | sensory_dist | boolean | float | integer | string | param | prop }

// ── Comparison operators ────────────────────────────────

comp_op = { "<=" | ">=" | "!=" | "<" | ">" | "=" }

// ── String match operators ──────────────────────────────

string_op = @{ ("CONTAINS" | "STARTS_WITH" | "ENDS_WITH") ~ !ident_tail }

// ── Conditions ──────────────────────────────────────────

comparison   = { atom ~ comp_op ~ atom }
in_list      = { "(" ~ atom ~ ("," ~ atom)* ~ ")" }
in_cond      = { atom ~ kw_in ~ in_list }
between_cond = { atom ~ kw_between ~ atom ~ kw_and ~ atom }
string_cond  = { atom ~ string_op ~ atom }
not_cond     = { kw_not ~ primary_cond }
paren_cond   = { "(" ~ or_cond ~ ")" }
primary_cond = { not_cond | paren_cond | in_cond | between_cond | string_cond | comparison }
and_cond     = { primary_cond ~ (kw_and ~ primary_cond)* }
or_cond      = { and_cond ~ (kw_or ~ and_cond)* }
conditions   = { or_cond }
where_clause = { kw_where ~ conditions }

// ── Graph patterns ──────────────────────────────────────

// (alias) or (alias:Label)
node_pattern = { "(" ~ ident ~ (":" ~ ident)? ~ ")" }

// Edge direction — typed or anonymous; optional hop range for variable-length paths
edge_label = @{ ident }
hop_range  = { "*" ~ integer ~ (".." ~ integer)? }
edge_out   = { "-[:" ~ edge_label ~ hop_range? ~ "]->" | "-->" }
edge_in    = { "<-[:" ~ edge_label ~ hop_range? ~ "]-" | "<--" }
edge_dir   = { edge_out | edge_in }

// (a)-[:TYPE]->(b) or (a)-->(b)
path_pattern = { node_pattern ~ edge_dir ~ node_pattern }

// Either a path or a lone node
pattern      = { path_pattern | node_pattern }
match_clause = { kw_match ~ pattern }

// ── RETURN ──────────────────────────────────────────────

// ORDER BY expr [ASC|DESC]
order_dir  = { "DESC" | "ASC" }
order_expr = { math_func | hyperbolic_dist | sensory_dist | prop | ident }
order_by   = { kw_order ~ kw_by ~ order_expr ~ order_dir? }

// LIMIT n / SKIP n
limit_clause = { kw_limit ~ integer }
skip_clause  = { kw_skip ~ integer }

// Items: n, n.energy, COUNT(n.energy), n.energy AS e
as_alias     = { kw_as ~ ident }
return_item  = { (agg_func | prop | ident) ~ as_alias? }

// GROUP BY
group_by_item = { prop | ident }
group_by      = { kw_group ~ kw_by ~ group_by_item ~ ("," ~ group_by_item)* }

// DISTINCT marker (non-silent so we detect its presence)
distinct_kw = { kw_distinct }

return_clause = {
    kw_return ~ distinct_kw?
    ~ return_item ~ ("," ~ return_item)*
    ~ group_by?
    ~ order_by?
    ~ (skip_clause ~ limit_clause? | limit_clause ~ skip_clause?)?
}

// ── DIFFUSE query ───────────────────────────────────────

diffuse_from  = { param | ident }
diffuse_t     = { kw_with ~ "t" ~ "=" ~ num_list }
diffuse_hops  = { kw_max_hops ~ integer }
diffuse_query = {
    kw_diffuse ~ kw_from ~ diffuse_from
    ~ diffuse_t?
    ~ diffuse_hops?
    ~ return_clause?
}

// ── MERGE patterns ─────────────────────────────────────

prop_pair          = { ident ~ ":" ~ atom }
prop_map           = { "{" ~ prop_pair ~ ("," ~ prop_pair)* ~ "}" }
merge_node_pattern = { "(" ~ ident ~ (":" ~ ident)? ~ prop_map? ~ ")" }
merge_edge_pattern = { merge_node_pattern ~ edge_dir ~ merge_node_pattern }
merge_pattern      = { merge_edge_pattern | merge_node_pattern }

set_assignment   = { prop ~ "=" ~ atom }
set_clause       = { kw_set ~ set_assignment ~ ("," ~ set_assignment)* }
on_create_clause = { kw_on ~ kw_create ~ set_clause }
on_match_clause  = { kw_on ~ kw_match ~ set_clause }

merge_query = {
    kw_merge ~ merge_pattern
    ~ on_create_clause?
    ~ on_match_clause?
    ~ return_clause?
}

// ── MATCH query (extended with SET / DELETE) ────────────
//
// Three forms:
//   MATCH (n) WHERE … RETURN …                  — read query
//   MATCH (n) WHERE … SET n.x = val [RETURN …]  — update query
//   MATCH (n) WHERE … DELETE n                   — delete query

match_query = {
    match_clause
    ~ where_clause?
    ~ as_of_cycle_clause?
    ~ (set_clause ~ return_clause? | delete_clause | return_clause)
}

// ── RECONSTRUCT query (Phase 11) ────────────────────────

reconstruct_target  = { param | ident }
modality_name       = @{ ident }
quality_level       = @{ ident }
reconstruct_query   = {
    kw_reconstruct ~ reconstruct_target
    ~ (kw_modality ~ modality_name)?
    ~ (kw_quality  ~ quality_level)?
}

// ── EXPLAIN query ───────────────────────────────────────

explain_query = { kw_explain ~ (reconstruct_query | diffuse_query | match_query) }

// ── INVOKE ZARATUSTRA query (Phase C) ───────────────────
//
// Examples:
//   INVOKE ZARATUSTRA
//   INVOKE ZARATUSTRA IN "memories" CYCLES 3 ALPHA 0.15 DECAY 0.01

zaratustra_in     = { kw_in ~ string }
zaratustra_cycles = { kw_cycles ~ integer }
zaratustra_alpha  = { kw_alpha  ~ float }
zaratustra_decay  = { kw_decay  ~ float }

invoke_zaratustra_query = {
    kw_invoke ~ kw_zaratustra
    ~ zaratustra_in?
    ~ zaratustra_cycles?
    ~ zaratustra_alpha?
    ~ zaratustra_decay?
}

// ── Transaction control queries (Phase F) ───────────────

begin_tx_query    = { kw_begin }
commit_tx_query   = { kw_commit }
rollback_tx_query = { kw_rollback }

// ── CREATE query ──────────────────────────────────────────
//
// Examples:
//   CREATE (n:Memory {title: "hello", energy: 0.9})
//   CREATE (n:Memory {title: "hello"}) RETURN n

create_node_pattern = { "(" ~ ident ~ (":" ~ ident)? ~ prop_map ~ ")" }
create_query        = { kw_create ~ create_node_pattern ~ return_clause? }

// ── MATCH … DELETE clause ─────────────────────────────────

delete_target  = { ident }
delete_clause  = { kw_delete ~ delete_target ~ ("," ~ delete_target)* }

// ── DAEMON queries ──────────────────────────────────────
//
// CREATE DAEMON guardian ON (n:Memory)
//   WHEN n.energy > 0.8
//   THEN DIFFUSE FROM n WITH t=[0.1, 1.0] MAX_HOPS 5
//   EVERY INTERVAL("1h")
//   ENERGY 0.8
//
// DROP DAEMON guardian
// SHOW DAEMONS

daemon_name = @{ ident }

// THEN action: DELETE n | SET n.x = v, … | DIFFUSE FROM n WITH t=[…] MAX_HOPS k
daemon_delete_action  = { kw_delete ~ ident }
daemon_set_action     = { kw_set ~ set_assignment ~ ("," ~ set_assignment)* }
daemon_diffuse_action = {
    kw_diffuse ~ kw_from ~ ident
    ~ diffuse_t?
    ~ diffuse_hops?
}
daemon_action = { daemon_delete_action | daemon_set_action | daemon_diffuse_action }

daemon_when   = { kw_when ~ conditions }
daemon_then   = { kw_then ~ daemon_action }
daemon_every  = { kw_every ~ atom }
daemon_energy = { kw_energy ~ (float | integer) }

create_daemon_query = {
    kw_create ~ kw_daemon ~ daemon_name
    ~ kw_on ~ node_pattern
    ~ daemon_when
    ~ daemon_then
    ~ daemon_every
    ~ daemon_energy?
}

drop_daemon_query  = { kw_drop ~ kw_daemon ~ daemon_name }
show_daemons_query = { kw_show ~ kw_daemons }

// ── DREAM queries (Phase 15.2) ──────────────────────────
//
// DREAM FROM $node DEPTH 3 NOISE 0.1
// APPLY DREAM $dream_id
// REJECT DREAM $dream_id
// SHOW DREAMS

dream_seed   = { param | ident }
dream_depth  = { kw_depth ~ integer }
dream_noise  = { kw_noise ~ (float | integer) }

dream_from_query = {
    kw_dream ~ kw_from ~ dream_seed
    ~ dream_depth?
    ~ dream_noise?
}

apply_dream_query  = { kw_apply ~ kw_dream ~ param }
reject_dream_query = { kw_reject ~ kw_dream ~ param }
show_dreams_query  = { kw_show ~ kw_dreams }

// ── TRANSLATE query (Phase 15.3 — Synesthesia) ─────────
//
// TRANSLATE $node FROM audio TO text QUALITY high

translate_target = { param | ident }
translate_from   = { kw_from ~ ident }
translate_to     = { kw_to ~ ident }
translate_query  = {
    kw_translate ~ translate_target
    ~ translate_from
    ~ translate_to
    ~ (kw_quality ~ quality_level)?
}

// ── AS OF CYCLE clause (Phase 15.4 — Eternal Return) ────
//
// MATCH (n) WHERE … AS OF CYCLE 3 RETURN …

as_of_cycle_clause = { kw_as_of ~ kw_cycle ~ integer }

// ── COUNTERFACTUAL query (Phase 15.4 — Eternal Return) ──
//
// COUNTERFACTUAL SET n.energy = 0.5 MATCH (n) WHERE … RETURN …

counterfactual_query = {
    kw_counterfactual ~ set_clause ~ match_query
}

// ── Collective Unconscious (Phase 15.6) ──────────────────
//
// SHOW ARCHETYPES
// SHARE ARCHETYPE $node_id TO "collection"

show_archetypes_query  = { kw_show ~ kw_archetypes }
share_archetype_query  = { kw_share ~ kw_archetype ~ param ~ kw_to ~ string }

// ── NARRATE query (Phase 15.7 — Narrative Engine) ────────
//
// NARRATE IN "memories" WINDOW 24 FORMAT json

narrate_in     = { kw_in ~ string }
narrate_window = { kw_window ~ integer }
narrate_format = { kw_format ~ ident }

narrate_query = {
    kw_narrate
    ~ narrate_in?
    ~ narrate_window?
    ~ narrate_format?
}

// ── Top-level ───────────────────────────────────────────

query = { SOI ~ (explain_query | invoke_zaratustra_query | begin_tx_query | commit_tx_query | rollback_tx_query | reconstruct_query | diffuse_query | show_dreams_query | apply_dream_query | reject_dream_query | dream_from_query | show_archetypes_query | share_archetype_query | show_daemons_query | drop_daemon_query | create_daemon_query | counterfactual_query | translate_query | narrate_query | create_query | merge_query | match_query) ~ EOI }
